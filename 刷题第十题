输入string是 s:string, p:pattern。找出pattern是否和整个string相等，其中.可以代表一位任意字符(包括*)，*可以代表任意长度的(包括0位)前位字符。
#此题比较难，还需要继续考虑。
#主要是利用递归的思想，迭代的调用当前函数，这里是尾递归，就是每次在返回时调用当前函数，所以和使用for loop其实是一样的，python的迭代效率不高，所以以后最好改一个for loop的version出来
class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        利用递归的思想，根据匹配字符串p的下一字符是不是'*'分两种情况处理：
        1. p的下个字符是'*'，如果p和s当前字符相同或p当前字符是'.'，则一直往右移动直到p没                   有'.*'或'x*'这样的情况，递归判断（x是指跟s相同的字符）
        2. p的下个字符不是'*'，如果p和s当前字符相同或p当前字符是'.'，则p和s往右移动一个字符，递归判断
        """
        #判断条件基本上是跟着p的长度来的，同时需要判断p的第二位是不是*，这么判断是因为这个第二位可以代替任意位长度的前位字符
        if len(p) == 0:
            #如果两个都是空字符，返回true
            if len(s) == 0:
                return True
            #如果s不是空字符，那p肯定不是s的pattern
            if len(s) != 0:
                return False
        #注意这里在判断p的长度是否为1的同时判断了p的第二位是否不是*，这么做的原因是为了简化判断逻辑。
        #「因为只要p第二位不是*，就判断s和p的第一位是否相同。
        #如果不同或者不是.那就可以直接返回false，因为除非第一位是.只要是其他的字符又不相等，那s和p肯定不能match。
        #同时，如果s的长度为0，那同样的不可能match」
        #除了第二位是否是*的判断外，还需要考虑p只有一位的情况，若p只有一位，就判断s和p第一位是否相等，若不相等就不可能match
        elif len(p) == 1 or p[1] != "*":
            if len(s) == 0 or (p[0]!= "." and p[0]!=s[0]):
                return False
            #除了以上所有的情况，同时把s和p挪动一位检查是否相等。挪动到下一位的前提是s和p的第一位相match。
            #即便p只有一位，这样的挪动也是有效的，因为只要s和p第一位相等，如果s和p都只有一位，那挪动一位后两个都是空，也是match的；如果s还有其他位数，p只有一位那就不match，返回false
            else:
                return self.isMatch(s[1:], p[1:])
  
        #这里是整个算法最精华的部分，考虑完p长度为1或第二位不为*（或者说不用一个一个逐次挪动s和p判断）时，就要考虑p长度大于1，同时第二位为*
        #只有在s长度不为0切s和p第一位都相等的时候才进入while loop，进入while loop的隐含条件是必须先满足上面的p长度大于1且第二位为*
        #这样s和p第一位相等后，就逐步判断无论*重复n次，s的前n位是否都和p[0]相等。这个判断成立的原因是每次都不对p进行改变，p一直保持不变，只是迭代的时候直接
        取了p的*后的位数，但并没有更新p，但是s是有变化的。这个while loop就可以确保如果p中的*重复了n次，s的前n位都是等于p[0]的，也就是s[n]到p[n]都是match的
        
        while len(s) != 0 and (s[0]==p[0] or p[0]=="."):
                    #进入while loop以后就要分两种情况，1.*后的p和整个s直接match，这样即便s[0]和p[0]match了，也可以不用看，因为*可以表示重复0次
                    if self.isMatch(s, p[2:]):
                        return True
                    #如果不match的话就把s挪动一位，重新返回while loop，这样while loop就可以检查*重复了n次是否和s[前n位]是否相等
                    s=s[1:]
        #当while loop不在成立时有两种情况，1.是之前已经进入过while loops[前n]和p[0]+*重复n次都已经match，s[n+1位]已经和p[0]不match，
        这样直接看剩下的s和*位之后的p是否相等就可以
        2.是没进入过while loop，s和p第一位不match，所以就直接看p*后的位数和s是否match
        return self.isMatch(s, p[2:])
        
